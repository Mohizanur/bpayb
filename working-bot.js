// Final working bot with minimal handlers to avoid conflicts
import { Telegraf } from 'telegraf';
import dotenv from 'dotenv';
import { firestore } from './src/utils/firestore.js';
import { setupStartHandler } from './src/handlers/start.js';
import { loadI18n } from './src/utils/i18n.js';
import { loadServices } from './src/utils/loadServices.js';

dotenv.config();

console.log('üöÄ BirrPay Bot - Final Working Version');

const bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN, {
  telegram: { webhookReply: false }
});

// Load resources
let i18n, services;
try {
  console.log("Loading i18n and services...");
  i18n = await loadI18n();
  services = await loadServices();
  console.log("Successfully loaded resources");
} catch (error) {
  console.error("Error loading resources:", error);
  i18n = { hero_title: { en: "Welcome", am: "·ä•·äï·ä≥·äï ·ã∞·àµ ·ä†·àà·ãé·âµ" } };
  services = [];
}

// Language middleware
bot.use(async (ctx, next) => {
  try {
    if (ctx.from?.id && firestore) {
      try {
        const userDoc = await firestore.collection('users').doc(String(ctx.from.id)).get();
        if (userDoc.exists) {
          ctx.userLang = userDoc.data().language || ctx.from.language_code || 'en';
        } else {
          ctx.userLang = ctx.from.language_code || 'en';
        }
      } catch (error) {
        ctx.userLang = ctx.from?.language_code || 'en';
      }
    } else {
      ctx.userLang = ctx.from?.language_code || 'en';
    }
    
    if (ctx.userLang?.startsWith('am')) ctx.userLang = 'am';
    else ctx.userLang = 'en';
    
    ctx.i18n = i18n;
    ctx.services = services;
    
    return next();
  } catch (error) {
    console.error('Error in middleware:', error);
    ctx.userLang = 'en';
    ctx.i18n = i18n;
    ctx.services = services;
    return next();
  }
});

// Debug middleware
bot.use(async (ctx, next) => {
  if (ctx.message && ctx.message.text) {
    console.log(`üì• Command: "${ctx.message.text}" from user ${ctx.from.id}`);
  }
  return next();
});

console.log("Registering handlers...");

// Register ONLY the start handler (we know this works)
setupStartHandler(bot);

// Register our working admin command LAST
bot.command('admin', async (ctx) => {
  console.log(`üîß ADMIN HANDLER TRIGGERED for user ${ctx.from.id}`);
  
  try {
    // Auth check (same as successful test)
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();
    
    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      console.log('‚ùå Admin access denied');
      await ctx.reply("‚ùå **Access Denied**\n\nThis command is restricted to authorized administrators only.");
      return;
    }
    
    console.log('‚úÖ Loading admin panel...');
    
    // Load real Firebase data
    const [usersSnapshot, subscriptionsSnapshot, paymentsSnapshot, pendingPaymentsSnapshot, servicesSnapshot] = await Promise.all([
      firestore.collection('users').get(),
      firestore.collection('subscriptions').get(),
      firestore.collection('payments').get(),
      firestore.collection('pendingPayments').get(),
      firestore.collection('services').get()
    ]);

    const totalUsers = usersSnapshot.size;
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const userData = doc.data();
      return userData.status !== 'banned' && userData.status !== 'suspended';
    }).length;

    const activeSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'active'
    ).length;

    const pendingSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'pending'
    ).length;

    const totalPayments = paymentsSnapshot.size;
    const pendingPayments = pendingPaymentsSnapshot.size;
    
    let totalRevenue = 0;
    pendingPaymentsSnapshot.docs.forEach(doc => {
      const paymentData = doc.data();
      if (paymentData.status === 'approved' && paymentData.amount) {
        totalRevenue += parseFloat(paymentData.amount) || 0;
      }
    });

    const adminMessage = `üåü **BirrPay Admin Dashboard** üåü

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üëã **Welcome back, Administrator!**

üìä **Real-Time Analytics**
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ üë• **Users:** ${totalUsers.toLocaleString()} total ‚Ä¢ ${activeUsers.toLocaleString()} active
‚îÉ üì± **Subscriptions:** ${activeSubscriptions.toLocaleString()} active ‚Ä¢ ${pendingSubscriptions.toLocaleString()} pending  
‚îÉ üí≥ **Payments:** ${totalPayments.toLocaleString()} total ‚Ä¢ ${pendingPayments.toLocaleString()} pending
‚îÉ üí∞ **Revenue:** ETB ${totalRevenue.toLocaleString('en-US', {minimumFractionDigits: 2})}
‚îÉ üõçÔ∏è **Services:** ${servicesSnapshot.size} available
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

üåê **Web Admin Panel:** [Open Dashboard](https://bpayb.onrender.com/panel)

üéØ **Management Center:**`;

    const keyboard = [
      [{ text: 'üë• Users', callback_data: 'admin_users' }, { text: 'üìä Subscriptions', callback_data: 'admin_subscriptions' }],
      [{ text: 'üéØ Custom Plans', callback_data: 'admin_custom_plans' }, { text: 'üí≥ Payment Methods', callback_data: 'admin_payments' }],
      [{ text: '‚è≥ Pending Approvals', callback_data: 'admin_pending' }, { text: 'üìä Analytics', callback_data: 'admin_analytics' }],
      [{ text: 'üí¨ Broadcast Message', callback_data: 'admin_broadcast' }],
      [{ text: 'üîÑ Refresh Panel', callback_data: 'refresh_admin' }]
    ];

    await ctx.reply(adminMessage, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });
    
    console.log('‚úÖ Admin panel sent successfully');
    
  } catch (error) {
    console.error('‚ùå Error in admin handler:', error);
    await ctx.reply('‚ùå Error loading admin panel: ' + error.message);
  }
});

// Add admin button handlers
// Enhanced admin_users handler with ban/unban capabilities
bot.action('admin_users', async (ctx) => {
  try {
    console.log('üë• Admin users button clicked');
    
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    // Get users with different filters
    const [allUsersSnapshot, bannedUsersSnapshot] = await Promise.all([
      firestore.collection('users').orderBy('createdAt', 'desc').limit(20).get(),
      firestore.collection('users').where('status', '==', 'banned').limit(10).get()
    ]);

    const totalUsers = allUsersSnapshot.size;
    const bannedCount = bannedUsersSnapshot.size;
    const activeCount = totalUsers - bannedCount;

    let usersList = `üë• **User Management**\n\n`;
    usersList += `üìä **Overview:**\n`;
    usersList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    usersList += `üë• Total Users: ${totalUsers}\n`;
    usersList += `‚úÖ Active: ${activeCount} ‚Ä¢ üö´ Banned: ${bannedCount}\n\n`;
    
    usersList += `üìã **Recent Users (Latest 20):**\n`;
    usersList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    allUsersSnapshot.docs.forEach((doc, index) => {
      const userData = doc.data();
      const status = userData.status === 'banned' ? 'üö´' : userData.status === 'suspended' ? '‚è∏Ô∏è' : '‚úÖ';
      const username = userData.username ? `@${userData.username}` : 'No username';
      
      usersList += `${index + 1}. ${status} **${userData.firstName || 'Unknown'}**\n`;
      usersList += `   üë§ ${username}\n`;
      usersList += `   üì± ID: \`${doc.id}\`\n`;
      usersList += `   üìÖ Joined: ${userData.createdAt?.toDate?.()?.toLocaleDateString() || 'Unknown'}\n\n`;
    });

    const keyboard = [
      [
        { text: 'üëÅÔ∏è View User Details', callback_data: 'view_user_prompt' },
        { text: 'üö´ Ban/Unban User', callback_data: 'ban_user_prompt' }
      ],
      [
        { text: 'üìä User Statistics', callback_data: 'user_stats' },
        { text: 'üîç Search Users', callback_data: 'search_users' }
      ],
      [{ text: 'üîÑ Refresh', callback_data: 'admin_users' }],
      [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
    ];

    await ctx.editMessageText(usersList, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_users:', error);
    await ctx.answerCbQuery('‚ùå Error loading users');
  }
});

// Enhanced admin_subscriptions handler (matching original button name)
bot.action('admin_subscriptions', async (ctx) => {
  try {
    console.log('üìã Admin subscriptions button clicked');
    
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    // Get subscription statistics
    const [allSubsSnapshot, activeSubsSnapshot, pendingSubsSnapshot] = await Promise.all([
      firestore.collection('subscriptions').get(),
      firestore.collection('subscriptions').where('status', '==', 'active').get(),
      firestore.collection('subscriptions').where('status', '==', 'pending').get()
    ]);

    const totalSubs = allSubsSnapshot.size;
    const activeSubs = activeSubsSnapshot.size;
    const pendingSubs = pendingSubsSnapshot.size;

    // Get recent subscriptions
    const recentSubsSnapshot = await firestore
      .collection('subscriptions')
      .orderBy('createdAt', 'desc')
      .limit(15)
      .get();

    let subsList = `üìã **Subscription Management**\n\n`;
    subsList += `üìä **Overview:**\n`;
    subsList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    subsList += `üì± Total: ${totalSubs} subscriptions\n`;
    subsList += `‚úÖ Active: ${activeSubs} ‚Ä¢ ‚è≥ Pending: ${pendingSubs}\n\n`;
    
    subsList += `üìã **Recent Subscriptions (Latest 15):**\n`;
    subsList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    recentSubsSnapshot.docs.forEach((doc, index) => {
      const subData = doc.data();
      const statusIcon = subData.status === 'active' ? '‚úÖ' : subData.status === 'pending' ? '‚è≥' : '‚ùå';
      subsList += `${index + 1}. ${statusIcon} **${subData.serviceName || subData.service || 'Unknown Service'}**\n`;
      subsList += `   üë§ User: \`${subData.userId}\`\n`;
      subsList += `   üí∞ Amount: ${subData.amount || subData.price || 0} ETB\n`;
      subsList += `   üìÖ Status: ${subData.status || 'unknown'}\n\n`;
    });

    const keyboard = [
      [
        { text: '‚úÖ Active Subscriptions', callback_data: 'admin_active' },
        { text: '‚è≥ Pending Approvals', callback_data: 'admin_pending_subs' }
      ],
      [
        { text: 'üéØ Custom Plans', callback_data: 'admin_custom_plans' },
        { text: 'üìä Subscription Stats', callback_data: 'admin_sub_stats' }
      ],
      [{ text: 'üîÑ Refresh', callback_data: 'admin_subscriptions' }],
      [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
    ];

    await ctx.editMessageText(subsList, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_subscriptions:', error);
    await ctx.answerCbQuery('‚ùå Error loading subscriptions');
  }
});

// Keep the old admin_subs for backward compatibility
bot.action('admin_subs', async (ctx) => {
  // Redirect to the enhanced subscription handler
  ctx.callbackQuery.data = 'admin_subscriptions';
  return bot.emit('callback_query', ctx.callbackQuery);
});

bot.action('admin_payments', async (ctx) => {
  try {
    console.log('üí∞ Admin payments button clicked');
    const paymentsSnapshot = await firestore.collection('pendingPayments').limit(15).get();
    
    let paymentsList = `üí∞ **Payment Management**\n\nüí≥ **Pending Payments (Latest 15):**\n`;
    paymentsList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
    
    paymentsSnapshot.docs.forEach((doc, index) => {
      const paymentData = doc.data();
      const statusIcon = paymentData.status === 'approved' ? '‚úÖ' : paymentData.status === 'rejected' ? '‚ùå' : '‚è≥';
      paymentsList += `${index + 1}. ${statusIcon} **${paymentData.amount || 0} ETB**\n`;
      paymentsList += `   üë§ User: \`${paymentData.userId}\`\n`;
      paymentsList += `   üõçÔ∏è Service: ${paymentData.service || 'Unknown'}\n`;
      paymentsList += `   üìÖ Status: ${paymentData.status || 'pending'}\n\n`;
    });
    
    await ctx.editMessageText(paymentsList, {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîÑ Refresh', callback_data: 'admin_payments' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_payments:', error);
    await ctx.answerCbQuery('‚ùå Error loading payments');
  }
});

bot.action('admin_services', async (ctx) => {
  try {
    console.log('üõçÔ∏è Admin services button clicked');
    const servicesSnapshot = await firestore.collection('services').get();
    
    let servicesList = `üõçÔ∏è **Service Management**\n\nüì¶ **Available Services:**\n`;
    servicesList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
    
    servicesSnapshot.docs.forEach((doc, index) => {
      const serviceData = doc.data();
      servicesList += `${index + 1}. **${serviceData.name || doc.id}**\n`;
      servicesList += `   üìù Description: ${serviceData.description || 'No description'}\n`;
      servicesList += `   üè∑Ô∏è ID: \`${doc.id}\`\n\n`;
    });
    
    await ctx.editMessageText(servicesList, {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîÑ Refresh', callback_data: 'admin_services' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_services:', error);
    await ctx.answerCbQuery('‚ùå Error loading services');
  }
});

bot.action('admin_analytics', async (ctx) => {
  try {
    console.log('üìä Admin analytics button clicked');
    
    const [users, subs, payments] = await Promise.all([
      firestore.collection('users').get(),
      firestore.collection('subscriptions').get(),
      firestore.collection('pendingPayments').get()
    ]);
    
    const today = new Date();
    const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    const recentUsers = users.docs.filter(doc => {
      const userData = doc.data();
      return userData.createdAt?.toDate?.() >= lastWeek;
    }).length;
    
    const activeSubs = subs.docs.filter(doc => doc.data().status === 'active').length;
    const pendingSubs = subs.docs.filter(doc => doc.data().status === 'pending').length;
    
    let totalRevenue = 0;
    payments.docs.forEach(doc => {
      const paymentData = doc.data();
      if (paymentData.status === 'approved' && paymentData.amount) {
        totalRevenue += parseFloat(paymentData.amount) || 0;
      }
    });
    
    const analyticsMsg = `üìä **Advanced Analytics**

üìà **Growth Statistics:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë• **Total Users:** ${users.size}
üìÖ **New Users (Last 7 days):** ${recentUsers}
üìã **Total Subscriptions:** ${subs.size}
‚úÖ **Active Subscriptions:** ${activeSubs}
‚è≥ **Pending Subscriptions:** ${pendingSubs}
üí∞ **Total Revenue:** ${totalRevenue.toFixed(2)} ETB
üí≥ **Pending Payments:** ${payments.size}

üìä **Conversion Rate:** ${subs.size > 0 ? ((activeSubs / subs.size) * 100).toFixed(1) : 0}%
üíπ **Avg Revenue/User:** ${users.size > 0 ? (totalRevenue / users.size).toFixed(2) : 0} ETB

‚è∞ **Generated:** ${new Date().toLocaleString()}`;
    
    await ctx.editMessageText(analyticsMsg, {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîÑ Refresh Analytics', callback_data: 'admin_analytics' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_analytics:', error);
    await ctx.answerCbQuery('‚ùå Error loading analytics');
  }
});

bot.action('admin_settings', async (ctx) => {
  try {
    const settingsMsg = `‚öôÔ∏è **System Settings**

üîß **Configuration Options:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîê **Admin Management**
üìä **Database Settings**
üõ†Ô∏è **Bot Configuration**
üí≥ **Payment Methods**
üåê **Language Settings**
üìß **Notification Settings**

‚ö†Ô∏è **Warning:** Changing settings requires admin privileges and may affect system operation.`;
    
    await ctx.editMessageText(settingsMsg, {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîê Manage Admins', callback_data: 'admin_manage_admins' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_settings:', error);
    await ctx.answerCbQuery('‚ùå Error loading settings');
  }
});

bot.action('admin_broadcast', async (ctx) => {
  try {
    const broadcastMsg = `üîî **Broadcast Message**

üì¢ **Send message to all users:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö†Ô∏è **Important:** Broadcasting sends messages to ALL registered users. Use responsibly.

üìù **Instructions:**
1. Type your message after clicking "Start Broadcast"
2. Message will be sent to all users
3. Process cannot be undone

üìä **Current user count:** Loading...`;
    
    await ctx.editMessageText(broadcastMsg, {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üì¢ Start Broadcast', callback_data: 'admin_start_broadcast' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_broadcast:', error);
    await ctx.answerCbQuery('‚ùå Error loading broadcast');
  }
});

bot.action('admin_export', async (ctx) => {
  try {
    const exportMsg = `üìÅ **Data Export**

üíæ **Available Export Options:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë• **Users Data** (CSV format)
üìã **Subscriptions Data** (CSV format)
üí∞ **Payments Data** (CSV format)
üõçÔ∏è **Services Data** (JSON format)
üìä **Analytics Report** (PDF format)

‚ö†Ô∏è **Note:** Export may take a few minutes for large datasets.`;
    
    await ctx.editMessageText(exportMsg, {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üë• Export Users', callback_data: 'export_users' },
            { text: 'üìã Export Subs', callback_data: 'export_subs' }
          ],
          [{ text: 'üìä Full Report', callback_data: 'export_full' }],
          [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in admin_export:', error);
    await ctx.answerCbQuery('‚ùå Error loading export options');
  }
});

bot.action('admin_refresh', async (ctx) => {
  try {
    // Manually trigger admin panel refresh
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();
    
    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery('‚ùå Access denied');
      return;
    }
    
    // Reload admin panel (copy from admin command)
    const [usersSnapshot, subscriptionsSnapshot, paymentsSnapshot, pendingPaymentsSnapshot, servicesSnapshot] = await Promise.all([
      firestore.collection('users').get(),
      firestore.collection('subscriptions').get(),
      firestore.collection('payments').get(),
      firestore.collection('pendingPayments').get(),
      firestore.collection('services').get()
    ]);

    const totalUsers = usersSnapshot.size;
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const userData = doc.data();
      return userData.status !== 'banned' && userData.status !== 'suspended';
    }).length;

    const activeSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'active'
    ).length;

    const pendingSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'pending'
    ).length;

    const totalPayments = paymentsSnapshot.size;
    const pendingPayments = pendingPaymentsSnapshot.size;
    
    let totalRevenue = 0;
    pendingPaymentsSnapshot.docs.forEach(doc => {
      const paymentData = doc.data();
      if (paymentData.status === 'approved' && paymentData.amount) {
        totalRevenue += parseFloat(paymentData.amount) || 0;
      }
    });

    const adminMessage = `üîß **BirrPay Admin Panel**

üìä **Live System Statistics:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë• **Users:** ${totalUsers} total (${activeUsers} active)
üìã **Subscriptions:** ${subscriptionsSnapshot.size} total
   ‚îú‚îÄ‚îÄ ‚úÖ Active: ${activeSubscriptions}
   ‚îî‚îÄ‚îÄ ‚è≥ Pending: ${pendingSubscriptions}
üí∞ **Payments:** ${totalPayments} total (${pendingPayments} pending)
üíµ **Revenue:** ${totalRevenue.toFixed(2)} ETB
üõçÔ∏è **Services:** ${servicesSnapshot.size} available

‚è∞ **Updated:** ${new Date().toLocaleString()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üéØ **Admin Quick Actions:**`;

    const keyboard = [
      [
        { text: 'üë• Manage Users', callback_data: 'admin_users' },
        { text: 'üìã Subscriptions', callback_data: 'admin_subs' }
      ],
      [
        { text: 'üí∞ Payments', callback_data: 'admin_payments' },
        { text: 'üõçÔ∏è Services', callback_data: 'admin_services' }
      ],
      [
        { text: 'üìä Analytics', callback_data: 'admin_analytics' },
        { text: '‚öôÔ∏è Settings', callback_data: 'admin_settings' }
      ],
      [
        { text: 'üîî Broadcast Message', callback_data: 'admin_broadcast' },
        { text: 'üìÅ Export Data', callback_data: 'admin_export' }
      ],
      [
        { text: 'üîÑ Refresh Stats', callback_data: 'admin_refresh' }
      ],
      [
        { text: 'üè† Back to Main Menu', callback_data: 'back_to_start' }
      ]
    ];

    await ctx.editMessageText(adminMessage, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });
    
    await ctx.answerCbQuery('üîÑ Stats refreshed!');
    console.log('‚úÖ Admin panel refreshed');
    
  } catch (error) {
    console.error('Error refreshing admin panel:', error);
    await ctx.answerCbQuery('‚ùå Error refreshing');
  }
});

bot.action('admin_back', async (ctx) => {
  try {
    // Same as refresh - go back to main admin panel
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();
    
    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery('‚ùå Access denied');
      return;
    }
    
    // Load main admin panel
    const [usersSnapshot, subscriptionsSnapshot, paymentsSnapshot, pendingPaymentsSnapshot, servicesSnapshot] = await Promise.all([
      firestore.collection('users').get(),
      firestore.collection('subscriptions').get(),
      firestore.collection('payments').get(),
      firestore.collection('pendingPayments').get(),
      firestore.collection('services').get()
    ]);

    const totalUsers = usersSnapshot.size;
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const userData = doc.data();
      return userData.status !== 'banned' && userData.status !== 'suspended';
    }).length;

    const activeSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'active'
    ).length;

    const pendingSubscriptions = subscriptionsSnapshot.docs.filter(doc => 
      doc.data().status === 'pending'
    ).length;

    const totalPayments = paymentsSnapshot.size;
    const pendingPayments = pendingPaymentsSnapshot.size;
    
    let totalRevenue = 0;
    pendingPaymentsSnapshot.docs.forEach(doc => {
      const paymentData = doc.data();
      if (paymentData.status === 'approved' && paymentData.amount) {
        totalRevenue += parseFloat(paymentData.amount) || 0;
      }
    });

    const adminMessage = `üîß **BirrPay Admin Panel**

üìä **Live System Statistics:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë• **Users:** ${totalUsers} total (${activeUsers} active)
üìã **Subscriptions:** ${subscriptionsSnapshot.size} total
   ‚îú‚îÄ‚îÄ ‚úÖ Active: ${activeSubscriptions}
   ‚îî‚îÄ‚îÄ ‚è≥ Pending: ${pendingSubscriptions}
üí∞ **Payments:** ${totalPayments} total (${pendingPayments} pending)
üíµ **Revenue:** ${totalRevenue.toFixed(2)} ETB
üõçÔ∏è **Services:** ${servicesSnapshot.size} available

‚è∞ **Updated:** ${new Date().toLocaleString()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üéØ **Admin Quick Actions:**`;

    const keyboard = [
      [
        { text: 'üë• Manage Users', callback_data: 'admin_users' },
        { text: 'üìã Subscriptions', callback_data: 'admin_subs' }
      ],
      [
        { text: 'üí∞ Payments', callback_data: 'admin_payments' },
        { text: 'üõçÔ∏è Services', callback_data: 'admin_services' }
      ],
      [
        { text: 'üìä Analytics', callback_data: 'admin_analytics' },
        { text: '‚öôÔ∏è Settings', callback_data: 'admin_settings' }
      ],
      [
        { text: 'üîî Broadcast Message', callback_data: 'admin_broadcast' },
        { text: 'üìÅ Export Data', callback_data: 'admin_export' }
      ],
      [
        { text: 'üîÑ Refresh Stats', callback_data: 'admin_refresh' }
      ],
      [
        { text: 'üè† Back to Main Menu', callback_data: 'back_to_start' }
      ]
    ];

    await ctx.editMessageText(adminMessage, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });
    
    await ctx.answerCbQuery('‚¨ÖÔ∏è Back to admin panel');
    console.log('‚úÖ Returned to admin panel');
    
  } catch (error) {
    console.error('Error returning to admin panel:', error);
    await ctx.answerCbQuery('‚ùå Error going back');
  }
});

// Handle back to start from admin
bot.action('back_to_start', async (ctx) => {
  try {
    await ctx.editMessageText('üè† **Welcome back to BirrPay!**\n\nUse /start to see the main menu or /admin for admin panel.', {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üè† Main Menu', callback_data: 'start_menu' }]
        ]
      },
      parse_mode: 'Markdown'
    });
    await ctx.answerCbQuery();
  } catch (error) {
    console.error('Error in back_to_start:', error);
    await ctx.answerCbQuery();
  }
});

// ENHANCED ADMIN HANDLERS FROM ORIGINAL ADMIN.JS

// Handle pending payments review (KEY FEATURE)
bot.action('admin_pending', async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    console.log('‚è≥ Loading pending payments...');

    // Get all pending payments
    const pendingSnapshot = await firestore
      .collection('pendingPayments')
      .where('status', '==', 'proof_submitted')
      .get();

    if (pendingSnapshot.empty) {
      await ctx.editMessageText("‚úÖ **No Pending Payment Approvals**\n\nAll payments have been processed.", {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üîô Back to Admin', callback_data: 'back_to_admin' }]
          ]
        }
      });
      await ctx.answerCbQuery();
      return;
    }

    const pendingPayments = [];
    for (const doc of pendingSnapshot.docs) {
      const payment = { id: doc.id, ...doc.data() };
      
      // Get user info
      try {
        const userDoc = await firestore.collection('users').doc(payment.userId).get();
        const userData = userDoc.exists ? userDoc.data() : {};
        payment.userInfo = {
          firstName: userData.firstName || 'Unknown',
          lastName: userData.lastName || '',
          username: userData.username || 'No username'
        };
      } catch (error) {
        console.error('Error fetching user info for payment:', payment.id, error);
        payment.userInfo = {
          firstName: 'Unknown',
          lastName: '',
          username: 'No username'
        };
      }
      
      pendingPayments.push(payment);
    }

    // Sort payments by creation date (newest first)
    pendingPayments.sort((a, b) => {
      const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt || 0);
      const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt || 0);
      return dateB - dateA;
    });

    // Show pending payments list
    let paymentsList = `‚è≥ **Pending Payment Approvals** (${pendingPayments.length})\n\n`;
    paymentsList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    pendingPayments.forEach((payment, index) => {
      const userDisplay = payment.userInfo.username !== 'No username' 
        ? `@${payment.userInfo.username}`
        : `${payment.userInfo.firstName} ${payment.userInfo.lastName}`.trim();
      
      const amount = payment.price || payment.amount || 'N/A';
      const service = payment.serviceTitle || payment.service || 'Unknown Service';
      const date = payment.createdAt?.toDate ? payment.createdAt.toDate().toLocaleDateString() : 'Unknown';
      
      paymentsList += `${index + 1}. üí≥ **${service}**\n`;
      paymentsList += `   üë§ User: ${userDisplay}\n`;
      paymentsList += `   üí∞ Amount: ETB ${amount}\n`;
      paymentsList += `   üìÖ Date: ${date}\n`;
      paymentsList += `   üÜî ID: \`${payment.id}\`\n\n`;
    });

    const keyboard = [];
    // Add review buttons for each payment (limit to first 10)
    const paymentsToShow = pendingPayments.slice(0, 10);
    for (let i = 0; i < paymentsToShow.length; i++) {
      keyboard.push([{ 
        text: `üìã Review Payment ${i + 1}`, 
        callback_data: `review_payment_${paymentsToShow[i].id}` 
      }]);
    }
    
    keyboard.push([{ text: 'üîô Back to Admin', callback_data: 'back_to_admin' }]);

    await ctx.editMessageText(paymentsList, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });

    await ctx.answerCbQuery();
    console.log('‚úÖ Pending payments loaded');

  } catch (error) {
    console.error('Error loading pending payments:', error);
    await ctx.answerCbQuery('‚ùå Error loading pending payments');
  }
});

// Handle payment review
bot.action(/^review_payment_(.+)$/, async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const paymentId = ctx.match[1];
    const paymentDoc = await firestore.collection('pendingPayments').doc(paymentId).get();

    if (!paymentDoc.exists) {
      await ctx.answerCbQuery('‚ùå Payment not found');
      return;
    }

    const payment = paymentDoc.data();
    
    // Get user info
    const userDoc = await firestore.collection('users').doc(payment.userId).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    
    const userDisplay = userData.username 
      ? `@${userData.username}`
      : `${userData.firstName || 'Unknown'} ${userData.lastName || ''}`.trim();

    const reviewMessage = `üí≥ **Payment Review**

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üë§ **User:** ${userDisplay}
üõçÔ∏è **Service:** ${payment.serviceTitle || payment.service || 'Unknown'}
üí∞ **Amount:** ETB ${payment.price || payment.amount || 'N/A'}
üí≥ **Method:** ${payment.paymentMethod || 'Unknown'}
üìÖ **Date:** ${payment.createdAt?.toDate?.()?.toLocaleString() || 'Unknown'}
üÜî **Payment ID:** \`${paymentId}\`

üì± **User ID:** \`${payment.userId}\`
üìã **Status:** ${payment.status || 'pending'}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîç **Admin Actions:**`;

    const keyboard = [
      [
        { text: '‚úÖ Approve Payment', callback_data: `approve_payment_${paymentId}` },
        { text: '‚ùå Reject Payment', callback_data: `reject_payment_${paymentId}` }
      ],
      [{ text: 'üë§ View User Details', callback_data: `view_user_${payment.userId}` }],
      [{ text: 'üîô Back to Pending', callback_data: 'admin_pending' }]
    ];

    await ctx.editMessageText(reviewMessage, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });

    await ctx.answerCbQuery();

  } catch (error) {
    console.error('Error reviewing payment:', error);
    await ctx.answerCbQuery('‚ùå Error loading payment details');
  }
});

// Handle payment approval
bot.action(/^approve_payment_(.+)$/, async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const paymentId = ctx.match[1];
    
    // Update payment status to approved
    await firestore.collection('pendingPayments').doc(paymentId).update({
      status: 'approved',
      approvedAt: new Date(),
      approvedBy: userId
    });

    await ctx.answerCbQuery('‚úÖ Payment approved!');
    
    // Refresh to show updated pending list
    ctx.callbackQuery.data = 'admin_pending';
    await ctx.editMessageText('‚úÖ Payment approved! Refreshing pending list...');
    
    // Trigger pending list refresh after a moment
    setTimeout(() => {
      bot.emit('callback_query', ctx.callbackQuery);
    }, 1000);

    console.log(`‚úÖ Payment ${paymentId} approved by admin ${userId}`);

  } catch (error) {
    console.error('Error approving payment:', error);
    await ctx.answerCbQuery('‚ùå Error approving payment');
  }
});

// Handle payment rejection  
bot.action(/^reject_payment_(.+)$/, async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const paymentId = ctx.match[1];
    
    // Update payment status to rejected
    await firestore.collection('pendingPayments').doc(paymentId).update({
      status: 'rejected',
      rejectedAt: new Date(),
      rejectedBy: userId
    });

    await ctx.answerCbQuery('‚ùå Payment rejected');
    
    // Refresh to show updated pending list
    ctx.callbackQuery.data = 'admin_pending';
    await ctx.editMessageText('‚ùå Payment rejected. Refreshing pending list...');
    
    // Trigger pending list refresh after a moment
    setTimeout(() => {
      bot.emit('callback_query', ctx.callbackQuery);
    }, 1000);

    console.log(`‚ùå Payment ${paymentId} rejected by admin ${userId}`);

  } catch (error) {
    console.error('Error rejecting payment:', error);
    await ctx.answerCbQuery('‚ùå Error rejecting payment');
  }
});

// User management handlers (ban/unban functionality)

// Handle view user details
bot.action(/^view_user_(.+)$/, async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const targetUserId = ctx.match[1];
    const userDoc = await firestore.collection('users').doc(targetUserId).get();

    if (!userDoc.exists) {
      await ctx.answerCbQuery('‚ùå User not found');
      return;
    }

    const userData = userDoc.data();
    const username = userData.username ? `@${userData.username}` : 'No username';
    const status = userData.status || 'active';
    const joinDate = userData.createdAt?.toDate?.()?.toLocaleString() || 'Unknown';
    const language = userData.language === 'am' ? 'Amharic' : 'English';

    // Get user's subscriptions
    const subscriptionsSnapshot = await firestore
      .collection('subscriptions')
      .where('userId', '==', targetUserId)
      .get();

    const userMessage = `üë§ **User Details**

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üë§ **Name:** ${userData.firstName || 'Unknown'} ${userData.lastName || ''}
üè∑Ô∏è **Username:** ${username}
üì± **User ID:** \`${targetUserId}\`
üìä **Status:** ${status === 'banned' ? 'üö´ Banned' : status === 'suspended' ? '‚è∏Ô∏è Suspended' : '‚úÖ Active'}
üåê **Language:** ${language}
üìÖ **Joined:** ${joinDate}

üìã **Subscriptions:** ${subscriptionsSnapshot.size} total
${subscriptionsSnapshot.docs.map((doc, i) => {
  const sub = doc.data();
  return `   ${i + 1}. ${sub.service || 'Unknown'} (${sub.status || 'unknown'})`;
}).join('\n') || '   No subscriptions'}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîß **Admin Actions:**`;

    const keyboard = [
      [
        status !== 'banned' 
          ? { text: 'üö´ Ban User', callback_data: `ban_user_${targetUserId}` }
          : { text: '‚úÖ Unban User', callback_data: `unban_user_${targetUserId}` }
      ],
      [{ text: 'üìã View Subscriptions', callback_data: `user_subscriptions_${targetUserId}` }],
      [{ text: 'üí≥ View Payments', callback_data: `user_payments_${targetUserId}` }],
      [{ text: '‚¨ÖÔ∏è Back to Users', callback_data: 'admin_users' }]
    ];

    await ctx.editMessageText(userMessage, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });

    await ctx.answerCbQuery();

  } catch (error) {
    console.error('Error viewing user details:', error);
    await ctx.answerCbQuery('‚ùå Error loading user details');
  }
});

// Handle ban user
bot.action(/^ban_user_(.+)$/, async (ctx) => {
  try {
    const adminUserId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(adminUserId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const targetUserId = ctx.match[1];
    
    // Check if trying to ban another admin
    if (adminDoc.data().userIds?.includes(targetUserId)) {
      await ctx.answerCbQuery('‚ùå Cannot ban an admin user');
      return;
    }

    const userDoc = await firestore.collection('users').doc(targetUserId).get();
    if (!userDoc.exists) {
      await ctx.answerCbQuery('‚ùå User not found');
      return;
    }

    const userData = userDoc.data();
    const username = userData.username ? `@${userData.username}` : userData.firstName || 'Unknown';

    // Update user status to banned
    await firestore.collection('users').doc(targetUserId).update({
      status: 'banned',
      bannedAt: new Date(),
      bannedBy: adminUserId
    });

    await ctx.answerCbQuery('üö´ User banned successfully');
    
    // Show confirmation message
    await ctx.editMessageText(`üö´ **User Banned**\n\nüë§ User: ${username}\nüì± ID: \`${targetUserId}\`\n‚è∞ Banned: ${new Date().toLocaleString()}\nüëÆ By: Admin \`${adminUserId}\`\n\nThe user has been banned and can no longer use the bot.`, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: '‚úÖ Unban User', callback_data: `unban_user_${targetUserId}` }],
          [{ text: '‚¨ÖÔ∏è Back to Users', callback_data: 'admin_users' }]
        ]
      }
    });

    console.log(`üö´ User ${targetUserId} banned by admin ${adminUserId}`);

  } catch (error) {
    console.error('Error banning user:', error);
    await ctx.answerCbQuery('‚ùå Error banning user');
  }
});

// Handle unban user
bot.action(/^unban_user_(.+)$/, async (ctx) => {
  try {
    const adminUserId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(adminUserId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    const targetUserId = ctx.match[1];
    const userDoc = await firestore.collection('users').doc(targetUserId).get();
    
    if (!userDoc.exists) {
      await ctx.answerCbQuery('‚ùå User not found');
      return;
    }

    const userData = userDoc.data();
    const username = userData.username ? `@${userData.username}` : userData.firstName || 'Unknown';

    // Update user status to active (remove ban)
    await firestore.collection('users').doc(targetUserId).update({
      status: 'active',
      unbannedAt: new Date(),
      unbannedBy: adminUserId,
      bannedAt: null,
      bannedBy: null
    });

    await ctx.answerCbQuery('‚úÖ User unbanned successfully');
    
    // Show confirmation message
    await ctx.editMessageText(`‚úÖ **User Unbanned**\n\nüë§ User: ${username}\nüì± ID: \`${targetUserId}\`\n‚è∞ Unbanned: ${new Date().toLocaleString()}\nüëÆ By: Admin \`${adminUserId}\`\n\nThe user can now use the bot again.`, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üö´ Ban User Again', callback_data: `ban_user_${targetUserId}` }],
          [{ text: '‚¨ÖÔ∏è Back to Users', callback_data: 'admin_users' }]
        ]
      }
    });

    console.log(`‚úÖ User ${targetUserId} unbanned by admin ${adminUserId}`);

  } catch (error) {
    console.error('Error unbanning user:', error);
    await ctx.answerCbQuery('‚ùå Error unbanning user');
  }
});

// BROADCAST MESSAGING FEATURE
bot.action('admin_broadcast', async (ctx) => {
  try {
    const userId = ctx.from?.id?.toString();
    const adminDoc = await firestore.collection('config').doc('admins').get();

    if (!adminDoc.exists || !adminDoc.data().userIds?.includes(userId)) {
      await ctx.answerCbQuery("‚ùå Access denied.");
      return;
    }

    console.log('üì¢ Admin broadcast button clicked');

    // Get user statistics for broadcast info
    const usersSnapshot = await firestore.collection('users').get();
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const userData = doc.data();
      return userData.status !== 'banned' && userData.status !== 'suspended';
    }).length;

    const broadcastMessage = `üì¢ **Broadcast Message Center**

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üéØ **Send a message to all bot users**

üìä **Target Audience:**
üë• Total Users: ${usersSnapshot.size}
‚úÖ Active Users: ${activeUsers}
üö´ Banned Users: ${usersSnapshot.size - activeUsers}

‚ö†Ô∏è **Important:**
‚Ä¢ Messages will be sent to ALL active users
‚Ä¢ Banned users will NOT receive messages
‚Ä¢ This action cannot be undone
‚Ä¢ Use responsibly

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìù **Compose your broadcast message:**`;

    const keyboard = [
      [{ text: 'üìù Compose Message', callback_data: 'compose_broadcast' }],
      [{ text: 'üìã View Recent Broadcasts', callback_data: 'view_broadcasts' }],
      [{ text: '‚¨ÖÔ∏è Back to Admin', callback_data: 'admin_back' }]
    ];

    await ctx.editMessageText(broadcastMessage, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });

    await ctx.answerCbQuery();

  } catch (error) {
    console.error('Error in admin_broadcast:', error);
    await ctx.answerCbQuery('‚ùå Error loading broadcast center');
  }
});

console.log("‚úÖ Enhanced handlers registered");

// Set commands menu
async function setupMenu() {
  try {
    await bot.telegram.setMyCommands([
      { command: 'start', description: 'üè† Main menu and services' },
      { command: 'admin', description: 'üîë Admin panel (admin only)' }
    ]);
    console.log("‚úÖ Commands menu set");
  } catch (error) {
    console.error("‚ùå Menu setup failed:", error);
  }
}

// Start
async function start() {
  try {
    await setupMenu();
    console.log('üöÄ Starting bot...');
    await bot.launch();
    console.log('‚úÖ BirrPay Bot is running!');
    console.log('üì± Try /start and /admin');
    
    process.once('SIGINT', () => bot.stop('SIGINT'));
    process.once('SIGTERM', () => bot.stop('SIGTERM'));
    
  } catch (error) {
    console.error('‚ùå Error starting bot:', error);
  }
}

start();
